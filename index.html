<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German Dictation Tool</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fdfdfd;
            color: #1f2937;
            height: 100%;
            padding: 20px;
            overflow: hidden;
            margin: 0;
        }

        .container {
            max-width: 100%;
            width: 100%;
            height: calc(100% - 40px);
            margin: 0 auto;
            background: transparent;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .content { 
            padding: 0; 
            width: 100%; 
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ----- AUDIO SECTION ---------------------------------------------- */
        .audio-section {
            padding: 20px;
            margin-bottom: 24px;
            border-radius: 20px;
            text-align: center;
            color: #374151;
            width: 100%;
            overflow: visible !important;
            flex-shrink: 0;
        }

        .audio-controls { 
            display: flex; 
            flex-direction: column;
            align-items: center;
            gap: 16px; 
            margin-bottom: 28px; 
            overflow: visible !important;
        }

        /* FORCE LARGE DESKTOP SIZES - NO MEDIA QUERY DEPENDENCY */
        .player-pill {
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 50px;
            padding: 16px 40px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25),
                0 4px 12px rgba(168, 85, 247, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            min-width: 60%;
            max-width: 700px;
        }

        .progress-controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 700px;
            padding: 0 20px;
        }

        /* Simplified button styling - removed conflicting logic */
        .nav-btn {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            border: none !important;
            color: #475569 !important;
            font-weight: 600 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
        }

        .nav-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            color: #334155 !important;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15) !important;
            transform: translateY(-1px) !important;
        }

        .play-btn {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3) !important;
        }

        .play-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%) !important;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        /* Separate styling for each toggle button type */
        .toggle-btn {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            border: none !important;
            color: #475569 !important;
            font-weight: 600 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
        }

        .toggle-btn:hover {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            color: #334155 !important;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3) !important;
        }

        .toggle-btn.active:hover {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%) !important;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.speed-100 {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3) !important;
        }

        .toggle-btn.speed-100:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%) !important;
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.speed-75 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(251, 191, 36, 0.3) !important;
        }

        .toggle-btn.speed-75:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.speed-50 {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3) !important;
        }

        .toggle-btn.speed-50:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important;
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .secondary-btn {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3) !important;
        }

        .secondary-btn:hover {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%) !important;
            color: white !important;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        /* FORCE LARGE BUTTONS - OVERRIDE EVERYTHING */
        .nav-btn,
        .toggle-btn:not(.secondary-btn) {
            width: 60x;
            height: 60px;
            font-size: 20px;
        }

        .play-btn {
            width: 80px;
            height: 80px;
            font-size: 32px;
        }

        .secondary-btn {
            width: 48px;
            height: 48px;
            font-size: 18px;
            flex-shrink: 0;
        }

        .progress-container { 
            flex-grow: 0;
            flex-shrink: 0;
            width: 180px;
            height: 16px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 20px;
            overflow: hidden;
            margin: 0 12px;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-controls-row #timeDisplay {
            flex-shrink: 0;
            font-size: 16px;
            color: #6b7280;
            margin: 0;
            min-width: 100px;
            text-align: center;
            font-weight: 600;
        }

        .nav-btn,
        .play-btn,
        .toggle-btn { 
            border: none; 
            border-radius: 50%; 
            cursor: pointer; 
            transition: all .3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            outline: none;
            position: relative;
        }

        .nav-btn:disabled { 
            opacity:0.3; 
            cursor:not-allowed; 
        }

        .text-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
            transition: flex 0.3s ease;
        }

        .text-section.collapsed {
            flex: 0;
            min-height: 0;
        }

        .hint-display {
            margin: 20px 0;
            padding: 16px 20px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%);
            border: 2px solid #e879f9;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(232, 121, 249, 0.1);
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .hint-content {
            font-size: 18px;
            color: #374151;
            font-weight: 500;
            line-height: 1.5;
        }

        .play-btn {
            position: relative;
            width: 72px; 
            height: 72px;
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.3);
            font-size: 28px;
            color: white;
        }
        
        .play-btn:hover:not(:disabled) { 
            transform: translateY(-3px); 
            box-shadow: 0 12px 32px rgba(168, 85, 247, 0.4);
        }
        
        .play-btn:disabled{
            opacity:.5;
            cursor:not-allowed;
        }
        
        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
            z-index: 2;
        }
        
        .play-btn.playing::before { 
            width:4px;
            height:20px;
            background:white;
            box-shadow:8px 0 0 white; 
        }
        
        .play-btn:not(.playing)::before { 
            border-left:12px solid white; 
            border-top:8px solid transparent; 
            border-bottom:8px solid transparent; 
        }

        #timeDisplay { 
            min-width:110px; 
            font-size:16px; 
            color:#6b7280; 
            font-weight:500; 
            margin-left: 8px; 
            margin-right: 8px;
        }
        
        .progress-bar { 
            height:100%; 
            width:0%; 
            background:linear-gradient(90deg, #a855f7, #ec4899); 
            border-radius:20px; 
            transition:width .3s ease;
        }

        .input-area { 
            display:flex; 
            flex-direction:column; 
            gap:20px; 
            padding: 0; 
        }
        
        .input-field {
            width:100%; 
            min-height:75px; 
            padding:18px 22px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%); 
            color:#374151;
            border:2px solid #e879f9; 
            border-radius: 16px;
            font-size:22px;
            line-height:1.3;
            resize:vertical;
            transition:all .3s ease;
            box-shadow: 0 4px 16px rgba(232, 121, 249, 0.1);
        }
        
        .input-field:focus { 
            border-color:#c084fc; 
            box-shadow:0 0 0 4px rgba(192, 132, 252, 0.15), 0 4px 16px rgba(232, 121, 249, 0.2); 
            outline:none; 
            transform: translateY(-1px);
        }

        .input-field::placeholder {
            font-size: 17px !important;
            color: #9CA3AF;
            opacity: 1;
            line-height: 1.3;
            transition: color 0.3s ease;
            display: flex;
            align-items: center;
        }
        
        .live-feedback {
            min-height:56px;
            padding:18px 22px;
            background: linear-gradient(135deg, #ecfdf5 0%, #fef3ff 100%); 
            border: none; 
            border-radius: 16px;
            font-size:22px;
            line-height:1.3;
            white-space:pre-wrap; 
            word-break:break-word;
            color: #9ca3af;
            box-shadow: 0 4px 16px rgba(167, 139, 250, 0.1);
            display: block;
            width: 100%;
            box-sizing: border-box;
        }

        .char-correct{color:#059669;font-weight:500;} 
        .char-wrong-position{color:#d97706;font-weight:500;} 
        .char-wrong{color:#dc2626;text-decoration:underline;font-weight:500;} 
        .char-missing{color:#d97706;font-style:italic;font-weight:500;} 
        .char-extra{color:#2563eb;font-weight:500;} 
        .char-word-boundary,.char-char-space{color:#9ca3af;}

        .options { 
            display: none;
        }

        .stats-section {
            margin: 32px 0 0 0;
            padding-top: 24px;
            border-top: 1px solid #f3f4f6;
            flex-shrink: 0;
            max-height: 50vh;
            overflow-y: auto;
            transition: margin-top 0.3s ease;
        }

        .stats-section.active {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .stats-with-export {
            display: flex;
            align-items: flex-start;
            gap: 24px;
            margin-bottom: 24px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            flex: 1;
        }

        .export-button-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            flex-shrink: 0;
        }

        .export-csv-btn, .restart-btn {
            width: 64px;
            height: 64px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all .3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
            font-weight: 600;
        }

        .export-csv-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
        }

        .export-csv-btn:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
            transform: translateY(-1px);
        }

        .restart-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            font-size: 40px;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
        }

        .restart-btn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
            transform: translateY(-1px);
        }
        
        .stat-item{
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(168, 85, 247, 0.2);
            border-radius:8px;
            padding:12px 8px;
            text-align:center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            transition: all .3s ease;
        }
        
        .stat-item:hover{
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
            border-color: rgba(168, 85, 247, 0.4);
        }
        
        .stat-value{
            font-size:28px;
            font-weight:700;
            color:#e879f9;
            margin-bottom:4px;
            display:block;
            line-height: 1;
        }
        
        .stat-label{
            font-size:12px;
            font-weight:600;
            color:#6b7280;
            line-height: 1.2;
        }

        .reference-text{
            margin-top:24px;
            padding:20px;
            background:#fef9e7;
            border:1px solid #fcd34d;
            border-radius:8px;
            color:#92400e;
            display:none;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .sentence-results {
            margin-top: 32px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .sentences-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sentence-result {
            font-size: 18px;
            line-height: 1.6;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .result-word-correct {
            color: #059669;
            font-weight: 500;
        }

        .result-word-wrong {
            color: #dc2626;
            font-weight: 500;
            text-decoration: underline;
            cursor: pointer;
            position: relative;
        }

        .result-word-wrong:hover {
            background: rgba(220, 38, 38, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .result-word-missing {
            color: #d97706;
            font-style: italic;
            border-bottom: 2px dashed #d97706;
            display: inline-block;
            min-width: 1em;
            cursor: pointer;
            position: relative;
        }

        .result-word-missing:hover {
            background: rgba(217, 119, 6, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .result-word-extra {
            color: #2563eb;
            font-weight: 500;
            background: rgba(37, 99, 235, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .word-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .word-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #1f2937;
        }

        .word-tooltip.show {
            opacity: 1;
            pointer-events: auto;
        }

        .word-tooltip.adjust-left {
            left: 0;
            transform: translateX(0);
        }

        .word-tooltip.adjust-right {
            left: auto;
            right: 0;
            transform: translateX(0);
        }

        .word-tooltip.adjust-left::after {
            left: 20px;
        }

        .word-tooltip.adjust-right::after {
            left: auto;
            right: 20px;
        }

        .export-controls {
            text-align: center;
            margin: 24px 0;
            padding: 16px;
        }

       @media (max-width: 600px) {
            
            body { padding: 10px; }
            .audio-section{ padding: 15px; }
            
            .input-field::placeholder {
                font-size: 14px !important;
                line-height: 1.2;
            }

            .input-field, .live-feedback{ 
                padding: 12px 18px; 
                font-size: 18px;
                min-height: 50px;
            }
                .live-feedback {
                font-size: 18px;
                min-height: 44px;
            }
            .player-pill {
                padding: 8px 12px !important;
                gap: 8px !important;
                background: rgba(255, 255, 255, 0.98);
                border: 2px solid rgba(168, 85, 247, 0.4);
                box-shadow: 
                    0 12px 40px rgba(0, 0, 0, 0.25),
                    0 4px 12px rgba(168, 85, 247, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.6);
                max-width: calc(100vw - 40px) !important;
                min-width: auto !important;
                overflow: hidden;
            }

            .progress-container {
                width: 80px !important;
                height: 10px !important;
                background: rgba(255, 255, 255, 0.95);
                border: 2px solid rgba(168, 85, 247, 0.4);
                box-shadow: 
                    0 4px 16px rgba(0, 0, 0, 0.2),
                    inset 0 2px 4px rgba(0, 0, 0, 0.1);
                margin: 0 4px !important;
            }

            .progress-controls-row {
                max-width: calc(100vw - 60px) !important;
                gap: 6px !important;
                padding: 0 10px !important;
            }

            .nav-btn, .toggle-btn {
                width: 44px !important;
                height: 44px !important;
                font-size: 15px !important;
            }

            .play-btn {
                width: 53px !important;
                height: 53px !important;
                font-size: 22px !important;
            }

            .secondary-btn {
                width: 31px !important;
                height: 31px !important;
                font-size: 11px !important;
            }

            .progress-controls-row #timeDisplay {
                font-size: 10px !important;
                min-width: 50px !important;
                font-weight: normal !important;
            }

            .hint-display {
                margin: 15px 0;
                padding: 12px 16px;
            }
            
            .hint-content {
                font-size: 16px;
                line-height: 1.4;
            }

            /* Mobile stats styling - much smaller */
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .stat-item {
                padding: 12px 8px;
                border-radius: 8px;
            }

            .stat-value {
                font-size: 20px;
                margin-bottom: 4px;
            }

            .stat-label {
                font-size: 11px;
            }

            .stats-section.active {
                margin-top: 10px !important;
                padding-top: 10px !important;
            }

            .export-button-container {
                gap: 8px;
            }

            .export-csv-btn, .restart-btn {
                width: 40px;
                height: 40px;
                font-size: 10px;
            }

            .restart-btn {
                font-size: 16px;
            }

            .stats-with-export {
                gap: 12px;
                margin-bottom: 16px;
            }
        }

        /* Desktop override - MUST come after mobile to take precedence */
        @media (min-width: 601px) {
            .player-pill {
                padding: 16px 40px !important;
                gap: 20px !important;
            }

            .progress-controls-row {
                max-width: 700px !important;
                gap: 20px !important;
                padding: 0 20px !important;
            }

            .progress-container {
                width: 180px !important;
                height: 16px !important;
                margin: 0 12px !important;
            }

            .progress-controls-row #timeDisplay {
                font-size: 16px !important;
                min-width: 100px !important;
                font-weight: 600 !important;
            }

            .nav-btn,
            .toggle-btn:not(.secondary-btn) {
                width: 60px !important;
                height: 60px !important;
                font-size: 20px !important;
            }

            .play-btn {
                width: 80px !important;
                height: 80px !important;
                font-size: 32px !important;
            }

            .secondary-btn {
                width: 48px !important;
                height: 48px !important;
                font-size: 19px !important;
            }
        }

        .toggle-btn.end-button {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            line-height: 1;
            padding: 8px 12px;
        }

        .toggle-btn.end-button:hover {
            background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <!-- AUDIO SECTION -->
            <div class="audio-section">
                <div class="audio-controls">
                    <div class="player-pill">
                        <button class="nav-btn" id="prevBtn" title="Previous sentence">‹</button>
                        <button class="play-btn" id="playBtn"></button>
                        <button class="nav-btn" id="nextBtn" title="Next sentence">›</button>
                        <button class="toggle-btn" id="ignoreCaseBtn" title="Capitalization checking OFF">Aa</button>
                        <button class="toggle-btn" id="speedBtn" title="Playback Speed">100</button>
                    </div>
                    
                    <!-- Progress bar and controls row -->
                    <div class="progress-controls-row">
                        <button class="toggle-btn secondary-btn" id="hintBtn" title="Show expected sentence">?</button>
                        <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                        <span id="timeDisplay">0:00 / 0:00</span>
                        <button class="toggle-btn secondary-btn" id="endDictationBtn" title="End dictation & show stats">X</button>
                    </div>
                </div>
                <audio id="audioPlayer" preload="auto"></audio>
            </div>

            <!-- TEXT & FEEDBACK -->
            <div class="text-section">
                <!-- Hint display area - only appears when needed -->
                <div class="hint-display" id="hintDisplay" style="display: none;">
                    <div class="hint-content" id="hintContent"></div>
                </div>
                
                <div class="input-area">
                    <div class="live-feedback" id="liveFeedback">Live Feedback</div>
                    <textarea class="input-field" id="userInput" placeholder="" autofocus></textarea>
                </div>

                <div class="options">
                    <!-- Options moved to audio controls -->
                </div>

                <div class="reference-text" id="referenceText"></div>
            </div>

            <!-- STATS & CONTROLS -->
            <div class="stats-section">
                <div class="stats-with-export" id="statsSection" style="display:none;">
                    <div class="stats">
                        <div class="stat-item"><span class="stat-label">Accuracy</span><span class="stat-value" id="accuracyPercent">0%</span></div>
                        <div class="stat-item"><span class="stat-label">Correct</span><span class="stat-value" id="correctWords">0</span></div>
                        <div class="stat-item"><span class="stat-label">Wrong</span><span class="stat-value" id="wrongWords">0</span></div>
                        <div class="stat-item"><span class="stat-label">Time</span><span class="stat-value" id="timeTaken">0:00</span></div>
                    </div>
                    <div class="export-button-container">
                        <button class="restart-btn" id="restartBtn" title="Restart dictation">
                            ↻
                        </button>
                        <button class="export-csv-btn" id="exportCsvBtn" title="Export results as CSV file">
                            CSV
                        </button>
                    </div>
                </div>

                <!-- Detailed sentence results -->
                <div class="sentence-results" id="sentenceResults" style="display:none;">
                    <div class="sentences-container" id="sentencesContainer">
                        <!-- Sentences will be inserted here by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // MODERN AUTO-RESIZE SYSTEM: ResizeObserver + Fallback
        let lastReportedHeight = 0;
        let resizeTimeout = null;

        function sendHeightToParent() {
            // Clear any pending resize calls
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            // Use a small delay to ensure DOM is fully updated
            resizeTimeout = setTimeout(() => {
                const height = Math.max(
                    document.body.scrollHeight,
                    document.body.offsetHeight,
                    document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight,
                    document.documentElement.clientHeight
                );
                
                // Only send if height actually changed (prevent spam)
                if (height !== lastReportedHeight) {
                    lastReportedHeight = height;
                    if (window.parent !== window) {
                        window.parent.postMessage({ frameHeight: height }, '*');
                    }
                    console.log('Sent new height:', height);
                }
            }, 50);
        }

        function initializeAutoResize() {
            // Method 1: Modern ResizeObserver (preferred)
            if (window.ResizeObserver) {
                console.log('Using ResizeObserver (modern)');
                
                const resizeObserver = new ResizeObserver(entries => {
                    sendHeightToParent();
                });
                
                // Observe the main container for size changes
                const container = document.querySelector('.container');
                if (container) {
                    resizeObserver.observe(container);
                }
                
                // Also observe document body for additional safety
                resizeObserver.observe(document.body);
                
            } else {
                console.log('Using MutationObserver fallback (older browsers)');
                
                // Method 2: Fallback for older browsers
                const mutationObserver = new MutationObserver(() => {
                    sendHeightToParent();
                });
                
                // Watch for DOM changes that could affect height
                mutationObserver.observe(document.body, {
                    childList: true,      // Child elements added/removed
                    subtree: true,        // Watch all descendants
                    attributes: true,     // Attribute changes (style, class, etc.)
                    attributeFilter: ['style', 'class'], // Only watch relevant attributes
                });
                
                // Additional fallback: Window resize events
                window.addEventListener('resize', sendHeightToParent);
                
                // Backup polling for edge cases (very conservative)
                setInterval(() => {
                    sendHeightToParent();
                }, 5000); // Only every 5 seconds as last resort
            }
            
            // Initial height calculation
            sendHeightToParent();
        }

        // DOM ELEMENTS
        let audioPlayer, playBtn, progressBar, timeDisplay, referenceTextDiv, statsSection;
        let userInput, liveFeedback, accuracyPercent, correctWords, wrongWords;
        let endDictationBtn, ignoreCaseBtn, hintBtn, speedBtn;
        let prevBtn, nextBtn, exportCsvBtn;

        // GLOBAL STATE
        let referenceText = '';
        let isPlaying = false;
        let vttCues = [];
        let currentCueIndex = 0;
        let allLessons = {};
        let currentLessonId = '';
        let hasStartedTyping = false;
        let sentenceStartTime = null;
        let totalSessionTime = 0;
        let sessionResults = [];
        let ignoreCaseActive = true;
        let currentSpeed = 1.0;

        const initialPlaceholderText = "Shift+Cmd+Enter = Play/Pause\nae = ä | oe = ö | ue = ü | B = ß\nType here...";

        const CONFIG = {
            lessonsUrl: 'https://raw.githubusercontent.com/smarterGerman/dictation/main/lessons/lessons.json'
        };

        // INITIALIZATION
        window.addEventListener('load', function() {
            initializeDOMElements();
            setupEventListeners();
            initializeAutoResize();
            
            const lessonId = getLessonIdFromUrl() || 'A1L01';
            loadAllLessons().then(() => {
                loadLesson(lessonId);
            });
            
            window.focus();
        });

        function initializeDOMElements() {
            audioPlayer = document.getElementById('audioPlayer');
            playBtn = document.getElementById('playBtn');
            progressBar = document.getElementById('progressBar');
            timeDisplay = document.getElementById('timeDisplay');
            referenceTextDiv = document.getElementById('referenceText');
            statsSection = document.getElementById('statsSection');
            userInput = document.getElementById('userInput');
            
            if (userInput) {
                userInput.placeholder = initialPlaceholderText;
            }
            
            liveFeedback = document.getElementById('liveFeedback');
            accuracyPercent = document.getElementById('accuracyPercent');
            correctWords = document.getElementById('correctWords');
            wrongWords = document.getElementById('wrongWords');
            endDictationBtn = document.getElementById('endDictationBtn');
            ignoreCaseBtn = document.getElementById('ignoreCaseBtn');
            speedBtn = document.getElementById('speedBtn');
            hintBtn = document.getElementById('hintBtn');
            prevBtn = document.getElementById('prevBtn');
            nextBtn = document.getElementById('nextBtn');
            exportCsvBtn = document.getElementById('exportCsvBtn');
        }

        function setupEventListeners() {
            // Audio controls
            if (playBtn) playBtn.addEventListener('click', togglePlayback);
            if (prevBtn) prevBtn.addEventListener('click', goToPreviousSentence);
            if (nextBtn) nextBtn.addEventListener('click', goToNextSentence);
            
            // Input
            if (userInput) {
                userInput.addEventListener('input', handleUserInput);
                userInput.addEventListener('keydown', handleKeyDown);
            }
            
            // UI controls
            if (endDictationBtn) endDictationBtn.addEventListener('click', showFinalResult);
            
            if (ignoreCaseBtn) {
                ignoreCaseBtn.addEventListener('click', toggleIgnoreCase);
                ignoreCaseBtn.classList.remove('active');
                ignoreCaseBtn.title = "Capitalization checking OFF";
            }
            
            if (speedBtn) {
                speedBtn.addEventListener('click', toggleSpeed);
                speedBtn.classList.add('speed-100');
            }
            
            if (hintBtn) {
                hintBtn.addEventListener('click', showHint);
            }

            // Result buttons
            const restartBtn = document.getElementById('restartBtn');
            const exportBtn = document.getElementById('exportCsvBtn');
            
            if (restartBtn) {
                restartBtn.addEventListener('click', restartDictation);
                console.log('Restart button listener added');
            } else {
                console.log('Restart button not found');
            }
            
            if (exportBtn) {
                exportBtn.addEventListener('click', function() {
                    console.log('Export button clicked');
                    exportCSV();
                });
                console.log('Export button listener added');
            } else {
                console.log('Export button not found');
            }

            // Audio events
            if (audioPlayer) {
                audioPlayer.addEventListener('play', () => {
                    isPlaying = true;
                    if (playBtn) {
                        playBtn.classList.add('playing');
                    }
                    if (userInput) {
                        userInput.focus();
                    }
                });
                
                audioPlayer.addEventListener('pause', () => {
                    isPlaying = false;
                    if (playBtn) {
                        playBtn.classList.remove('playing');
                    }
                });
                
                audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
                
                audioPlayer.addEventListener('loadedmetadata', () => {
                    console.log(`[DEBUG] Metadata loaded. Duration: ${audioPlayer.duration.toFixed(2)}s. Network State: ${audioPlayer.networkState}.`);
                    if (playBtn) {
                        playBtn.classList.remove('playing');
                        playBtn.disabled = false;
                    }
                    audioPlayer.playbackRate = currentSpeed;
                    updateProgress();
                });
                
                audioPlayer.addEventListener('error', (e) => {
                    const error = e.target.error;
                    console.error('Audio Loading Error:', {
                        networkState: audioPlayer.networkState,
                        code: error ? error.code : 'N/A',
                        message: error ? error.message : 'Unknown Error',
                        event: e
                    });
                    if (playBtn) {
                        playBtn.disabled = true;
                        playBtn.style.opacity = '0.5';
                    }
                    alert('Error loading audio. Please check your internet connection or try refreshing the page.');
                });
            }

            // Global keyboard shortcuts
            window.addEventListener('keydown', handleGlobalKeyDown);
        }

        // SPEED CONTROL
        function toggleSpeed() {
            if (speedBtn) {
                speedBtn.classList.remove('speed-100', 'speed-75', 'speed-50');
            }
            
            if (currentSpeed === 1.0) {
                currentSpeed = 0.75;
                speedBtn.textContent = '75';
                speedBtn.classList.add('speed-75');
            } else if (currentSpeed === 0.75) {
                currentSpeed = 0.5;
                speedBtn.textContent = '50';
                speedBtn.classList.add('speed-50');
            } else {
                currentSpeed = 1.0;
                speedBtn.textContent = '100';
                speedBtn.classList.add('speed-100');
            }
            
            if (audioPlayer) {
                audioPlayer.playbackRate = currentSpeed;
            }
        }

        // CASE SENSITIVITY TOGGLE
        function toggleIgnoreCase() {
            ignoreCaseActive = !ignoreCaseActive;
            if (ignoreCaseBtn) {
                if (ignoreCaseActive) {
                    ignoreCaseBtn.classList.remove('active');
                    ignoreCaseBtn.title = "Capitalization checking OFF";
                } else {
                    ignoreCaseBtn.classList.add('active');
                    ignoreCaseBtn.title = "Capitalization checking ON";
                }
            }
            updateLiveFeedback();
        }

        // INPUT HANDLING
        function handleUserInput(e) {
            hideHint();
            
            if (!hasStartedTyping && e.target.value.trim().length > 0) {
                hasStartedTyping = true;
                sentenceStartTime = Date.now();
            }
            
            const cursorPos = e.target.selectionStart;
            const convertedText = convertGermanChars(e.target.value);
            if (convertedText !== e.target.value) {
                e.target.value = convertedText;
                e.target.setSelectionRange(cursorPos, cursorPos);
            }
            updateLiveFeedback();
            setTimeout(sendHeightToParent, 100);
        }

        // KEYBOARD SHORTCUTS
        function handleGlobalKeyDown(e) {
            console.log('Global keydown detected:', e.key, 'Shift:', e.shiftKey, 'Ctrl/Cmd:', (e.ctrlKey || e.metaKey));

            // Hint shortcut: Shift + Ctrl/Cmd + ß (German), / (US), , (French)
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && (e.key === 'ß' || e.key === '/' || e.key === ',')) {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }

            // Play/Pause: Shift + Ctrl/Cmd + Enter
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                console.log('Shortcut for togglePlayback activated.');
                togglePlayback();
                return;
            }

            // Sentence navigation: Shift + Ctrl/Cmd + Arrow keys
            if (e.shiftKey && (e.ctrlKey || e.metaKey)) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        goToPreviousSentence();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        goToNextSentence();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        playCurrentSentence();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        toggleSpeed();
                        break;
                }
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                processCurrentSentenceAndAdvance();
            }
        }

        // SENTENCE PROCESSING
        function processCurrentSentenceAndAdvance() {
            if (!userInput.value.trim()) {
                playCurrentSentence();
                return;
            }

            let sentenceTime = 0;
            if (hasStartedTyping && sentenceStartTime) {
                sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                totalSessionTime += sentenceTime;
            }

            const userText = userInput.value;
            const comparison = compareTexts(referenceText, userText);
            const wordStats = calculateWordStats(comparison);
            
            sessionResults.push({
                sentenceIndex: currentCueIndex,
                reference: referenceText,
                userInput: userText,
                stats: wordStats,
                time: sentenceTime,
                comparison: comparison
            });

            if (currentCueIndex < vttCues.length - 1) {
                goToNextSentence();
                playCurrentSentence();
            } else {
                showFinalResult();
            }
        }

        // URL PARSING
        function getLessonIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('lesson');
        }

        // LESSON LOADING
        async function loadAllLessons() {
            try {
                const response = await fetch(CONFIG.lessonsUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load lessons: ${response.status}`);
                }
                allLessons = await response.json();
            } catch (error) {
                console.error('Failed to load lessons:', error);
            }
        }

        // VTT PARSING - Enhanced to handle edge cases
        function parseVTT(vttText) {
            const lines = vttText.split('\n');
            const cues = [];
            let i = 0;

            // Skip headers and comments
            while (i < lines.length) {
                const line = lines[i].trim();
                if (line.includes('-->')) {
                    break;
                }
                // Skip WEBVTT headers, NOTE sections, STYLE sections
                if (line.startsWith('WEBVTT') || line.startsWith('NOTE') || line.startsWith('STYLE')) {
                    i++;
                    continue;
                }
                i++;
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                
                if (line.includes('-->')) {
                    const timeParts = line.split('-->');
                    if (timeParts.length >= 2) {
                        const startTime = timeParts[0].trim();
                        const endTime = timeParts[1].trim().split(' ')[0]; // Remove any positioning info
                        
                        const startSeconds = parseTimeToSeconds(startTime);
                        const endSeconds = parseTimeToSeconds(endTime);
                        
                        // Only proceed if we have valid times
                        if (!isNaN(startSeconds) && !isNaN(endSeconds)) {
                            i++;
                            let text = '';
                            while (i < lines.length && lines[i].trim() !== '') {
                                if (text) text += ' ';
                                // Remove any VTT tags like <v Speaker>, <c.classname>, etc.
                                const cleanLine = lines[i].trim().replace(/<[^>]*>/g, '');
                                text += cleanLine;
                                i++;
                            }
                            
                            if (text.trim()) {
                                cues.push({
                                    start: startSeconds,
                                    end: endSeconds,
                                    text: text.trim()
                                });
                            }
                        }
                    }
                }
                i++;
            }
            
            return cues;
        }

        function parseTimeToSeconds(timeStr) {
            try {
                // Handle both mm:ss.mmm and hh:mm:ss.mmm formats
                const parts = timeStr.split(':');
                const seconds = parts[parts.length - 1].split(/[.,]/); // Handle both . and , as decimal separator
                const sec = parseInt(seconds[0]) || 0;
                const ms = parseInt(seconds[1] || 0);
                
                if (parts.length === 3) {
                    const hours = parseInt(parts[0]) || 0;
                    const minutes = parseInt(parts[1]) || 0;
                    return hours * 3600 + minutes * 60 + sec + ms / 1000;
                } else if (parts.length === 2) {
                    const minutes = parseInt(parts[0]) || 0;
                    return minutes * 60 + sec + ms / 1000;
                } else {
                    return sec + ms / 1000;
                }
            } catch (error) {
                console.error('Error parsing time:', timeStr, error);
                return 0;
            }
        }

        async function loadVTTFromUrl(vttUrl) {
            try {
                const response = await fetch(vttUrl);
                if (!response.ok) {
                    throw new Error(`VTT file not found: ${response.status}`);
                }
                
                const vttText = await response.text();
                const cues = parseVTT(vttText);
                return cues;
            } catch (error) {
                console.error('Failed to load VTT file:', error);
                return [];
            }
        }

        // GERMAN CHARACTER CONVERSION
        function convertGermanChars(text) {
            return text
                .replace(/ae/g, 'ä')
                .replace(/oe/g, 'ö')
                .replace(/ue/g, 'ü')
                .replace(/Ae/g, 'Ä')
                .replace(/Oe/g, 'Ö')
                .replace(/Ue/g, 'Ü')
                .replace(/\B([aeiouäöü])B/g, '$1ß')
                .replace(/([aeiouäöü])B([aeiouäöü])/g, '$1ß$2')
                .replace(/([aeiouäöü])B$/g, '$1ß')
                .replace(/([aeiouäöü])B(\s)/g, '$1ß$2');
        }
        
        // AUDIO PLAYBACK
        function togglePlayback() {
            console.log(`[DEBUG] Play/Pause button tapped. IsPaused: ${audioPlayer.paused}. Current Network State: ${audioPlayer.networkState}.`);
            console.log('togglePlayback called.');
            
            if (vttCues.length === 0) {
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    audioPlayer.play().catch(error => {
                        console.log('Audio playback failed:', error);
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            } else {
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    playCurrentSentence();
                }
            }
        }

        function playCurrentSentence() {
            if (currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                const cue = vttCues[currentCueIndex];
                audioPlayer.currentTime = cue.start;
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('[DEBUG] Playback promise resolved (audio started).');
                    }).catch(error => {
                        console.error('Audio Playback Promise Rejected:', {
                            name: error.name,
                            message: error.message,
                            networkState: audioPlayer.networkState,
                            errorObject: error
                        });
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            }
        }

        // NAVIGATION
        function goToPreviousSentence() {
            if (currentCueIndex > 0) {
                currentCueIndex--;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function goToNextSentence() {
            if (currentCueIndex < vttCues.length - 1) {
                currentCueIndex++;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function updateCurrentSentence() {
            updateNavigationButtons();
            updateCurrentReferenceText();
            
            hideHint();
            
            if (userInput) userInput.value = '';
            if (userInput) {
                if (currentCueIndex < 2) {
                    userInput.placeholder = initialPlaceholderText;
                } else {
                    userInput.placeholder = "Type what you hear...";
                }
            }
            updateLiveFeedback();
            
            sentenceStartTime = null;
            hasStartedTyping = false;
            
            if (statsSection) statsSection.style.display = 'none';
            
            setTimeout(sendHeightToParent, 100);
        }

        function updateNavigationButtons() {
            if (prevBtn) prevBtn.disabled = (currentCueIndex <= 0);
            if (nextBtn) nextBtn.disabled = (currentCueIndex >= vttCues.length - 1);
        }

        function updateCurrentReferenceText() {
            if (vttCues.length > 0 && currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                referenceText = vttCues[currentCueIndex].text;
                if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            }
        }

        // TIME UPDATE
        function handleTimeUpdate() {
            updateProgress();
            
            if (vttCues.length > 0 && isPlaying) {
                const currentTime = audioPlayer.currentTime;
                const currentCue = vttCues[currentCueIndex];
                
                if (currentCue && currentTime >= currentCue.end) {
                    audioPlayer.pause();
                }
            }
        }

        // LESSON LOADING
        async function loadLesson(lessonId) {
            if (playBtn) {
                playBtn.disabled = true;
            }

            if (!allLessons[lessonId]) {
                console.error(`Lesson ${lessonId} not found`);
                return;
            }

            currentLessonId = lessonId;
            const lessonData = allLessons[lessonId];
            
            const cues = await loadVTTFromUrl(lessonData.vttUrl);
            
            if (cues.length === 0) {
                console.error(`Failed to load VTT for lesson ${lessonId}`);
                return;
            }
            
            vttCues = cues;
            currentCueIndex = 0;
            
            referenceText = vttCues[0].text;
            updateNavigationButtons();
            
            if (audioPlayer) {
                audioPlayer.src = lessonData.audioUrl;
                console.log(`[DEBUG] Attempting to load audio: ${lessonData.audioUrl.substring(lessonData.audioUrl.lastIndexOf('/') + 1)}. Current Network State: ${audioPlayer.networkState}.`);
            }
            
            if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            if (userInput) userInput.value = '';
            if (liveFeedback) liveFeedback.innerHTML = 'Live Feedback';
            if (statsSection) statsSection.style.display = 'none';
            
            sentenceStartTime = null;
            totalSessionTime = 0;
            hasStartedTyping = false;
            sessionResults = [];
            
            setTimeout(sendHeightToParent, 500);
        }

        // TEXT COMPARISON
        function compareTexts(reference, userText) {
            userText = convertGermanChars(userText);
            
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = reference;
            let userNormalized = userText;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            const result = [];
            let correct = 0;
            let wrongPosition = 0;
            let wrong = 0;
            let extra = 0;
            let missing = 0;
            
            for (let i = 0; i < alignment.length; i++) {
                const item = alignment[i];
                
                if (i > 0) {
                    result.push({ char: ' ', status: 'word-boundary' });
                }
                
                if (item.type === 'match') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'correct' });
                        correct++;
                    }
                } else if (item.type === 'substitute') {
                    const ref = item.refWord;
                    const user = item.userWord;

                    let missingPrefix = 0;
                    let missingSuffix = 0;

                    for (let idx = 1; idx <= ref.length; idx++) {
                        if (ref.slice(-idx) === user) {
                            missingPrefix = ref.length - idx;
                            break;
                        }
                    }
                    if (missingPrefix === 0) {
                        for (let idx = 1; idx <= ref.length; idx++) {
                            if (ref.slice(0, idx) === user) {
                                missingSuffix = ref.length - idx;
                                break;
                            }
                        }
                    }

                    if (missingPrefix > 0) {
                        for (let k = 0; k < missingPrefix; k++) {
                            if (k > 0) result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                    for (let c = 0; c < user.length; c++) {
                        result.push({ char: user[c], status: 'wrong' });
                        wrong++;
                    }

                    if (missingSuffix > 0) {
                        for (let k = 0; k < missingSuffix; k++) {
                            result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                } else if (item.type === 'insert') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'extra' });
                        extra++;
                    }
                } else if (item.type === 'delete') {
                    const wordLength = item.refWord.length;
                    
                    for (let k = 0; k < wordLength; k++) {
                        if (k > 0) {
                            result.push({ char: ' ', status: 'char-space' });
                        }
                        result.push({ char: '_', status: 'missing' });
                        missing++;
                    }
                }
            }
            
            return {
                chars: result,
                stats: { 
                    correct, 
                    wrongPosition, 
                    wrong, 
                    extra,
                    missing,
                    total: refNormalized.replace(/\s/g, '').length 
                }
            };
        }

        function alignSequencesWithGaps(refWords, userWords) {
            const N = refWords.length, M = userWords.length;
            const dp = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));

            const COST = { MATCH: 0, SUB: 3, INS: 2, DEL: 2 };

            for (let i = 0; i <= N; i++) dp[i][0] = i * COST.DEL;
            for (let j = 0; j <= M; j++) dp[0][j] = j * COST.INS;

            for (let i = 1; i <= N; i++) {
                for (let j = 1; j <= M; j++) {
                    const matchCost = dp[i - 1][j - 1] +
                        (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB);
                    const delCost = dp[i - 1][j] + COST.DEL;
                    const insCost = dp[i][j - 1] + COST.INS;

                    dp[i][j] = Math.min(matchCost, delCost, insCost);
                }
            }

            let i = N, j = M, alignment = [];
            while (i > 0 || j > 0) {
                const current = dp[i][j];

                if (i > 0 && j > 0 &&
                    current === dp[i - 1][j - 1] +
                               (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB)) {
                    alignment.unshift({
                        type: refWords[i - 1] === userWords[j - 1] ? 'match' : 'substitute',
                        refWord: refWords[i - 1],
                        userWord: userWords[j - 1]
                    });
                    i--; j--;
                    continue;
                }

                if (i > 0 && current === dp[i - 1][j] + COST.DEL) {
                    alignment.unshift({ type: 'delete', refWord: refWords[i - 1], userWord: null });
                    i--;
                    continue;
                }

                alignment.unshift({ type: 'insert', refWord: null, userWord: userWords[j - 1] });
                j--;
            }

            return alignment;
        }

        // LIVE FEEDBACK
        function updateLiveFeedback() {
            if (!userInput || !liveFeedback) return;
            
            const userText = userInput.value;
            
            if (userText.trim() === '') {
                liveFeedback.innerHTML = 'Live Feedback';
                return;
            }
            
            const comparison = compareTexts(referenceText, userText);
            
            let feedbackHTML = '';
            
            comparison.chars.forEach(item => {
                let char = item.char;
                
                if (char === ' ') {
                    if (item.status === 'word-boundary') {
                        char = '&nbsp;&nbsp;&nbsp;';
                    } else if (item.status === 'char-space') {
                        char = '';
                    } else {
                        char = '&nbsp;';
                    }
                } else if (char === '\n') {
                    char = '<br>';
                }
                
                feedbackHTML += `<span class="char-${item.status}">${char}</span>`;
            });
            
            liveFeedback.innerHTML = feedbackHTML;
        }

        // PROGRESS BAR
        function updateProgress() {
            if (!audioPlayer || !timeDisplay || !progressBar) return;
            
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            if (duration) {
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
                
                const formatTime = (time) => {
                    const minutes = Math.floor(time / 60);
                    const seconds = Math.floor(time % 60);
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                };
                
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }
        }

        // WORD STATISTICS
        function calculateWordStats(comparison) {
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = referenceText;
            let userNormalized = userInput.value;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let correctWords = 0;
            let wrongWords = 0;
            let totalWords = refWords.length;
            
            alignment.forEach(item => {
                if (item.type === 'match') {
                    correctWords++;
                } else if (item.type === 'substitute' || item.type === 'delete') {
                    wrongWords++;
                }
            });
            
            return {
                correctWords,
                wrongWords,
                totalWords
            };
        }

        // FINAL RESULTS
        function showFinalResult() {
            console.log('showFinalResult called');
            
            if (!userInput) return;
            
            // If there's text in the current sentence and it hasn't been processed yet
            if (userInput.value.trim() && sessionResults.length === currentCueIndex) {
                let sentenceTime = 0;
                if (hasStartedTyping && sentenceStartTime) {
                    sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                    totalSessionTime += sentenceTime;
                }

                const userText = userInput.value;
                const comparison = compareTexts(referenceText, userText);
                const wordStats = calculateWordStats(comparison);
                
                sessionResults.push({
                    sentenceIndex: currentCueIndex,
                    reference: referenceText,
                    userInput: userText,
                    stats: wordStats,
                    time: sentenceTime,
                    comparison: comparison
                });
            }
            
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            if (accuracyPercent) accuracyPercent.textContent = accuracy + '%';
            if (correctWords) correctWords.textContent = totalCorrectWords;
            if (wrongWords) wrongWords.textContent = totalWrongWords;

            const timeElement = document.getElementById('timeTaken');
            if (timeElement) {
                timeElement.textContent = formatTime(totalSessionTime);
            }
            
            // Hide input areas and collapse text section
            const inputArea = document.querySelector('.input-area');
            const textSection = document.querySelector('.text-section');
            if (inputArea) {
                inputArea.style.display = 'none';
            }
            if (textSection) {
                textSection.classList.add('collapsed');
            }
            
            // Show stats and move them up
            const statsContainer = document.querySelector('.stats-section');
            if (statsContainer) {
                statsContainer.classList.add('active');
            }
            if (statsSection) statsSection.style.display = 'flex';
            
            showDetailedResults();
                        
            setTimeout(sendHeightToParent, 100);
        }

        // CSV EXPORT
        function exportCSV() {
            console.log('exportCSV function called');
            console.log('sessionResults length:', sessionResults.length);
            
            if (sessionResults.length === 0) {
                console.log('No session results to export');
                alert('No results to export. Please complete some sentences first.');
                return;
            }
            
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            const lessonId = currentLessonId || 'Unknown';
            
            let csvContent = 'Lesson,Accuracy,Correct Words,Wrong Words,Total Words,Time Taken\n';
            csvContent += `${lessonId},${accuracy},${totalCorrectWords},${totalWrongWords},${totalWords},${formatTime(totalSessionTime)}`;
            
            console.log('CSV Content:', csvContent);
            
            try {
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${lessonId}-results.csv`;
                
                console.log('Creating download link:', link.download);
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('CSV export completed successfully');
            } catch (error) {
                console.error('Error during CSV export:', error);
                alert('Error exporting CSV file: ' + error.message);
            }
        }

        // DETAILED RESULTS
        function showDetailedResults() {
            const sentenceResultsDiv = document.getElementById('sentenceResults');
            const sentencesContainer = document.getElementById('sentencesContainer');
            
            if (!sentenceResultsDiv || !sentencesContainer) return;
            
            sentencesContainer.innerHTML = '';
            
            sessionResults.forEach((result, index) => {
                const sentenceDiv = document.createElement('div');
                sentenceDiv.className = 'sentence-result';
                sentenceDiv.innerHTML = generateResultHTML(result);
                
                sentencesContainer.appendChild(sentenceDiv);
            });
            
            addTooltipListeners();
            
            sentenceResultsDiv.style.display = 'block';
        }

        function generateResultHTML(result) {
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = result.reference;
            let userNormalized = convertGermanChars(result.userInput);
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let html = '';
            
            alignment.forEach((item, index) => {
                if (index > 0) html += ' ';
                
                if (item.type === 'match') {
                    html += `<span class="result-word-correct">${item.userWord}</span>`;
                } else if (item.type === 'substitute') {
                    html += `<span class="result-word-wrong" data-correct="${item.refWord}">${item.userWord}</span>`;
                } else if (item.type === 'insert') {
                    html += `<span class="result-word-extra">${item.userWord}</span>`;
                } else if (item.type === 'delete') {
                    const underscoreLength = Math.max(item.refWord.length, 3);
                    const underscore = '_'.repeat(underscoreLength);
                    html += `<span class="result-word-missing" data-missing="${item.refWord}">${underscore}</span>`;
                }
            });
            
            return html;
        }

        function addTooltipListeners() {
            const wrongWords = document.querySelectorAll('.result-word-wrong');
            const missingWords = document.querySelectorAll('.result-word-missing');
            
            wrongWords.forEach(word => {
                word.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showTooltip(this, this.getAttribute('data-correct'));
                });
            });

            missingWords.forEach(word => {
                word.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showTooltip(this, this.getAttribute('data-missing'));
                });
            });
        }

        function showTooltip(element, text) {
            // Clean up existing tooltips
            document.querySelectorAll('.word-tooltip').forEach(tooltip => tooltip.remove());
            
            const tooltip = document.createElement('div');
            tooltip.className = 'word-tooltip';
            tooltip.textContent = text;
            
            element.appendChild(tooltip);
            
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                const containerRect = document.querySelector('.sentences-container').getBoundingClientRect();
                
                if (tooltipRect.left < containerRect.left) {
                    tooltip.classList.add('adjust-left');
                }
                else if (tooltipRect.right > containerRect.right) {
                    tooltip.classList.add('adjust-right');
                }
                
                tooltip.classList.add('show');
            }, 10);
            
            // Clean up listener properly
            const cleanup = function(e) {
                if (!tooltip.contains(e.target) && !element.contains(e.target)) {
                    tooltip.remove();
                    document.removeEventListener('click', cleanup);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', cleanup);
            }, 100);
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // HINT SYSTEM
        function showHint() {
            if (!referenceText) return;
            
            const hintDisplay = document.getElementById('hintDisplay');
            const hintContent = document.getElementById('hintContent');
            
            if (!hintDisplay || !hintContent) return;
            
            // Set the hint text
            hintContent.textContent = referenceText;
            
            // Show the hint display
            hintDisplay.style.display = 'block';
            
            // ResizeObserver will automatically detect the change and resize
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                hideHint();
            }, 8000);
        }

        function hideHint() {
            const hintDisplay = document.getElementById('hintDisplay');
            if (hintDisplay && hintDisplay.style.display !== 'none') {
                hintDisplay.style.display = 'none';
            }
        }

        // RESTART FUNCTIONALITY
        function restartDictation() {
            console.log('Restart button clicked');
            
            // Reset all variables
            currentCueIndex = 0;
            hasStartedTyping = false;
            sentenceStartTime = null;
            totalSessionTime = 0;
            sessionResults = [];
            
            // Reset audio
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
            }
            
            // Reset UI elements
            if (userInput) {
                userInput.value = '';
                userInput.placeholder = initialPlaceholderText;
            }
            if (liveFeedback) {
                liveFeedback.innerHTML = 'Live Feedback';
            }
            
            // Show input areas and restore text section
            const inputArea = document.querySelector('.input-area');
            const textSection = document.querySelector('.text-section');
            if (inputArea) {
                inputArea.style.display = 'flex';
            }
            if (textSection) {
                textSection.classList.remove('collapsed');
            }
            
            // Hide stats and restore normal position
            const statsContainer = document.querySelector('.stats-section');
            if (statsContainer) {
                statsContainer.classList.remove('active');
            }
            if (statsSection) {
                statsSection.style.display = 'none';
            }
            
            // Hide detailed results
            const sentenceResults = document.getElementById('sentenceResults');
            if (sentenceResults) {
                sentenceResults.style.display = 'none';
            }
            
            // Update current sentence
            updateCurrentSentence();
            
            // Focus input
            if (userInput) {
                userInput.focus();
            }
            
            console.log('Restart complete');
        }
    </script>
</body>
</html>
